##### 个人介绍：

​		面试官您好，我叫***，我来自***，今年24岁，毕业于***大学，大学毕业后从事前端开发，到目前为止已经有三年工作经验，3年期间任职过一家公司，是北京万兴众信科技有限公司（北京市朝阳区百子湾路16号百子园5号楼10层B单元1007），我用到的主要技术栈就是vue全家桶、uni-app、微信小程序、JavaScript、ES6，我工作中经常与同事以及领导沟通，遇到问题会及时汇报解决，不会因为个人原因延误工期，本人具有较强的抗压能力，也比较容易融入到新的团队，以上就是我的自我介绍，谢谢！

#### 面试官问题

##### 大学主要课程：

程序设计基础与语言、面向对象程序设计、离散数学、电工电子技术、数字电子技术基础、数据结构、JAVA语言程序设计、计算机网络原理、微机原理与接口技术、数据库原理与应用、Android软件设计、软件工程、操作系统、单片机原理与应用、嵌入式系统。

##### 毕业时间：

2015.9.1--2019.7.1

##### 学校地址:

天津市西青区杨柳青柳口路 99号

##### 校长：马春光

##### 校训：

“学院“弘扬“尚德、敏行、笃实、创新”的校训精神”

##### 你为什么来我们公司:

我看了贵公司的职位说明，它的要求和我的非常吻合，（Vue html css web开发）所以我相信我一定能胜任这份工作；

##### 能接受加班吗:

可以接受

在我的工作完成之后  根据项目进度和公司需要  我会考虑是否加班

##### 上一家离职原因：

家里的一些私人原因，导致我需要请假的时间比较长，具体也不知道需要多久，也怕耽误公司项目进展，只能先离职了。

##### 上家公司的收获：

收获了极多的工作经验和一群可爱的同事

##### 到上家公司怎么走：

步行到天通苑地铁站B南口坐5号线——磁器口然后换成7号线——到大郊亭A西北口出再步行一公里左右

##### 现在住址:

北京-天通苑

##### 你对薪资的要求：

11k--14k

##### 为什么来北京:

因为有朋友在这里,再加上自己也想开阔眼界,增长阅历,希望自己能够得到提升,所以选择来到这里

##### 你对我们公司的了解:

提前上网查

##### 你为什么选择前端:

因为写的项目都可以直观看到相应的效果 写出来之后会很有成就感

#### 你们平时都是提交任务的？

我们有公共的仓库(git)，每天将代码拉取下来，更新代码。然后各自做完自己的代码后会将这些任务提交进去

#### 负责的模块，如果多人开发并发生冲突了怎么解决？

如何避免项目中的冲突或者或覆盖的问题，首先我们做项目都是提前沟通好的，比如我之前做的小项目，只需要用到我们两个前端人员，如果项目中出问题，我们会进行沟通商量协调，看看是哪里出的问题，如何解决。

多人开发项目，为了防止这样的冲突，我们会在公司自己的gitee上创建项目分支，自己做完的任务进行检查提交到项目个人分支，最后组长会将我们各自提交的代码进行合并，如果项目中代码出现问题，可以知道是那个提交的，找到问题所在出处，并及时解决

#### 如何搭建项目，搭建项目都需要做什么，你会怎么先做些什么？

我会先看看这个项目的大致内容需求，以及用到多少个页面，然后去创建对应的页面文件，并且看看有没有需要用到组件的地方，会根据情况创建组件的方式，如果用到的比较多，我会将组件在main.js中引入，设置全局组件。并且会看要用到的接口是否存在跨域的问题，如果存在跨域，会创建一个config.js文件在这里面配置跨域。

以及，我们会先封装一下axios,封装接口请求和常用到的404这些页面，需要提前配置好。当然我们会经常使用到的一些框架，路由，字体图标的引入安装。

#### vue项目中,接手别人代码的，如何去分析？

1. 首先对于Vue Cli搭建的项目，知道项目的目录结构
2. 查看 package.json 配置文件，了解项目引用了哪些额外插件和框架
3. 查看 router 文件，可以快速梳理项目脉络
4. 查看 vuex 文件（如果项目使用了 vuex，那vuex在其中一定扮演着非常重要的角色 ，时不时一些数据就是从vuex中取得的），通过这点可以大概明白整体项目的数据流向；除此之外通过vue devtool查看vuex也是个方法
5. 一定要看的main.js入口文件，其中vue.use()和import 引入的文件都对梳理项目架构很重要
6. 还有src目录下的components组件

#### 创建项目需要

__1.项目从无到有的过程：__

1.产品经理根据客户的需求文档

2.召集所有这个项目相关的工作人员进行开会商讨（项目的开发时间及上线时间和预算——前端需要几个人，后端需要几个人）

3.UI一般根据产品经理提出的需求文档绘制一个原型图

4.UI开始出UI图

5.项目经理或组长进行项的分工

6.前端人员需要跟后端人员进行沟通（后端出一个项目的接口文档）

7.前后端分别开发

8.完成之后前后端进行联调（接口能不能跑的通，数据能不能显示）

9.测试

10.上线

__2.项目初始化__
A. 安装Vue脚手架
B. 通过脚手架创建项目
C. 配置路由
D. 配置Element-UI:在插件中安装，搜索vue-cli-plugin-element
E. 配置Axios：在依赖中安装,搜索axios(运行依赖)
F. 初始化git仓库
G. 将本地项目托管到github或gitee(码云)中

__3.前后端分离区别：__

前端符合页面效果和逻辑交互以及前后端数据交互

后端负责数据维护后端逻辑和前端接口(前后端差个接口文档)

运行依赖和开发依赖：

​	开发依赖：devDependencies 在线上状态不需要使用的依赖，就是开发依赖。

   运行依赖：dependencies 

__SPA__:指单页面是一次性把web应用的所有代码(HTML<JavaScript和Css)全部请求过来，然后根据前端路由切换不同模块的资源。



##### 开发过程中遇到的难点以及怎么解决的：

##### Vue2和Vue3的区别：

1.    2.x 版本中，使用 Vue.set 来给对象新增一个属性时，这个对象的所有 watcher 都会重新运行；3.x 版本中，只有依赖那个属性的 watcher 才会重新运行。

2.  移除了static文件夹，新增public文件夹。
3. 移除了static文件夹，新增public文件夹，并且index.html移动到public中。
4. 在src文件夹中新增了views文件夹，用于分类视图组件和公共组件。

##### 项目中遇到的难点：

使用swiper的时候 数据请求回来了css代码也没问题,但图片不动
	主要原因是:swiper提前初始化,而这个时候数据还没有完全出来
	解决方法:两个,一个从swiper入手,一个从vue入手
	vue方法:vue中专门提供了一个方法nextTick()用于 解决dom的先后执行问题.在mouned阶段,先执行异步请求数据之后写nextTick,在nextTick的里面写swiper的初始化.
	方法二:在swiper初始化的时候添加observer:true/observeParents:true这两个属性.
	初始化是数据请求先执行.所以图片不动.

##### 说一下你做过的上线项目：

```
答：上个项目是后台管理系统，我负责有登录和首页布局用户列表基本结构和权限管理还有角色列表还有商品分类。
模块的基本功能都有：登录页的话在登陆页面输入账号密码，讲数据发送给服务器。服务器返回登录的结果，成功返回的数据中带有token。在得到token后，将他进行保存，存储在本地存储中。登录成功之后，需要讲后台返回的token保存到本地存储中，操作完毕后，需要跳转到home页还有进行路由鉴权，如果没有登录，不能访问/home，强制跳转到登录页面。

首页的功能都有：侧边菜单栏的伸缩功能还有用户列表的基本结构和渲染用户列表基本结构。使用element-ui面包屑组件，完成顶部导航使用element-ui卡片组件完成主体表格。然后讲用户数据渲染。实现分页功能，实现更新用户状态，发送请求完成状态的更改，实现搜索功能，实现添加用户，修改用户信息根据id查询需要修改的用户数据，弹出框数据绑定及验证：删除用户：根据id删除相对应的数据。

权限管理：使用element-ui组件添加面包屑导航，显示数据添，加权限删除功能，完成树形结构弹窗，在element.js中引入Tree，注册Tree，对用户权限的添加权限和修改权限删除之类的。

分类管理：请求分类的数据 使用ui框架渲染页面 和分页的功能，实现添加分类还有很多。。。
```



##### 微信小程序的跳转：

wx.navigateTo

##### 微信的渲染层和逻辑层：

- `WXML` 模板和 `WXSS` 样式工作在渲染层，负责展示数据
- `JS` 脚本工作在逻辑层，负责产生、处理数据，通过Page 实例或者Component实例的 setData 方法传递数据到渲染层。

##### 项目流程：

业务方提出需求  产品经理收集需求  确定项目优化级  审查项目优先级  输出需求文档  审核需要文档  输出需求详细文档  产品原型 rpd（产品需求说明文档）业务逻辑流程图  研发部 ui设计师：原型评审 需求评审 业务逻辑   然后测试工程师 和   ui设计师提出意见  研发部 处理一些基础的东西   然后确定开发周期  后台和前台对接口  开发完成   测试服务器  产品业务方验收通过 部署上线  



##### 1.跨域（跨域解决方法）

 造成跨域的原因就是浏览器的同源策略：只要满足***\*协议\****、***\*主机\****、***\*端口\****一致，则两个页面具有相同的源。同源策略限制了从同一个源加载的文档或脚本如何来自另一个源的资源进行交互，这是一个用于隔离潜在恶意文件的重要安全机制。

***\*解决方法：\****

   ① jsonp，允许script加载第三方资源。jsonp是一种非正式的传输协议，这个协议的一个要点就是允许用户传递一个callback函数给服务端，然后服务端返回数据的时候会将json数据包裹在这个callback函数中返回。jsonp的本质是利用script标签的src属性进行跨域请求，但只能用于get请求。

   ② 反向代理 (nginx 服务内部配置 Access-Control-Allow-Origin *)；

   ③ cors 前后端协作设置请求头部，Access-Control-Allow-Origin 等头部信息 

   ④ iframe 嵌套通讯 (可以与下面的postmessage一起使用)

   ⑤ window.postmessage ( )，该方法的使用须与iframe嵌套使用。

**跨域的解决方案：**

```js
首先跨域的原因是由现在我们的前后端分离造成的。

开发阶段前端解决跨域的方法：
			 1、webpack proxy  （这种方式打包就没有了）
			 使用http-proxy-middleware 代理解决（项目使用vue-cli脚手架搭建）
				打开config/index.js,在proxyTable中添写如下代码：
                    proxyTable: { 
                      '/api': { 
                        target: '填写请求源地址', //源地址 
                        changeOrigin: true, //是否跨域
                        pathRewrite: { 
                          '^/api': '' //路径重写 
                          } 
                      } 
                    }
			 2、jsonp
			 3、nginx 反向代理 
项目上线后端设置：
	A） header('Access-Control-Allow-Origin:*');//允许所有来源访问 
	B） header('Access-Control-Allow-Method:POST,GET');//允许访问的方式

在之前的公司遇到跨域问题都是后台进行处理的。
```



##### 2.深拷贝和浅拷贝？

***\*浅拷贝：\****浅拷贝是会将对象的每个属性进行依次复制，但是当对象的属性值是引用类型时，实质复制的是其引用，当引用指向的值改变时也会跟着变化。

***\*深拷贝：\****深拷贝复制变量值，对于非基本类型的变量，则递归至基本类型变量后，再复制。 深拷贝后的对象与原来的对象是完全隔离的，互不影响，对一个对象的修改并不会影响另一个对象。

**深拷贝和浅拷贝是针对复杂数据类型来说的，浅拷贝只拷贝一层，而深拷贝是层层拷贝；**

##### 3.原型、原型链、构造函数

***\*原型（__proto__）：\****每个对象都有__proto__属性，__proto__指向创建他的构造函数的原型对象（prototype）。

***\*原型链：\****凡是对象都有一个原型，通过__proto__可以访问原型，访问的原型又是对象，这样依次下去，就会构成一个对象的序列，该结构成为原型链。

***\*构造函数：\****

① 构造函数的首字母必须大写，用来区分于普通函数；

② 内部使用的this对象，来指向即将要生成的实例对象；

③ 使用new来生成实例对象。

##### 4.作用域链、闭包、作用域；

***\*⑴ 作用域链\****

​    定义：一个函数在访问变量的时候，优先使用自己的局部变量，如果没有这个变量的申明，则向上级访问，一直访问到全局。全局都没有的话，语法错误：is not defined。

***\*⑵闭包closure\****

​    定义：当一个函数的返回值是另外一个函数,而返回的那个函数如果调用了其父函数的内部变量,且返回的那个函数在外部被执行,就产生了闭包.闭包是一个环境,具体指的就是外部函数--高阶函数

​    ***\*闭包的特性：\****

​      ①函数嵌套函数；

​      ②内部函数可以直接访问外部函数的内部变量或参数；

​      ③变量或参数不会被垃圾回收机制回收。

​    ***\*闭包的优点：\****

​      ①变量长期驻扎在内存中；

​      ②避免全局变量的污染；

​      ③私有成员的存在。

​    ***\*闭包的缺点：\**** 常驻内存，增大内存的使用量，使用不当会造成内存泄漏。

***\*⑶作用域：\****

es5中只有 全局作用域：window。函数作用域：函数内部定义的。会导致一些场景不合理，内层变量会覆盖外层变量（原因就是变量提升），用来计数的循环变量泄露为全局变量（ 变量i只用来控制循环，但是循环结束后，i变量并没有消失，而是泄漏为全局变量。），es6中的块级作用域let、const会解决这些问题，

##### 5.事件模型：事件委托、代理？如何让事件先冒泡后捕获？

事件委托：

又叫事件代理，利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。

事件捕获：

当一个事件触发后,从Window对象触发,不断经过下级节点,直到目标节点。在事件到达目标节点之前的过程就是捕获阶段。所有经过的节点,都会触发对应的事件。

***\*当为事件捕获(useCapture:true)时,先执行body的事件,再执行div的事件\****

事件冒泡：

当事件到达目标节点后，会沿着捕获阶段的路线原路返回。同样，所有经过的节点,都会触发对应的事件。

***\*当为事件冒泡(useCapture:false)时,先执行div的事件,再执行body的事件\****

先冒泡后捕获：

根据w3c标准，应先捕获再冒泡。若要实现先冒泡后捕获，给一个元素绑定两个addEventListener，其中一个第三个参数设置为false（即冒泡），另一个第三个参数设置为true（即捕获），调整它们的代码顺序，将设置为false的监听事件放在设置为true的监听事件前面即可。

##### 6.Promise的解释

Promise是异步编程解决方案之一。最大的好处是提供了一个then，来为异步提供回调函数。其先进之处是可以在then方法中继续写Promise对象并返回，然后继续用then来进行回调操作，并且能够在外层捕获异步函数的异常信息。

⑴Promise用法：

const fn = new Promise(function(resolve,reject){

axios.get(url).then(res => {

​    resolve(res);

  }).catch(err => {

​    reject(err);

  })

}).then((res) => {

  console.log(res);

}).catch((err) => {

  console.log(err);

})复制代码

⑵Promise原理：

   在Promise的内部，有一个状态管理器的存在，有三种状态：pending、fulfilled、rejected。

   ①promised对象初始化为pending；

   ②当调用resolve(成功)，会由pending => fulfilled。

   ③当调用reject(失败)，会由pending => rejected。

​    看上面的的代码中的resolve(num)其实是将promise的状态由pending改为fulfilled，然后向then的成功回掉函数传值，reject反之。但是需要记住的是注意promsie状态 只能由 pending => fulfilled/rejected, 一旦修改就不能再变。promise.then方法每次调用，都返回一个新的promise对象 所以可以链式写法（无论resolve还是reject都是这样）

 

⑶Promise的三个状态：

  pending：异步任务正在进行中；

  resolved(也可以叫fulfilled)，异步任务执行成功；

  rejected，异步任务执行失败。

 

⑷Promise对象初始化：

   ① new Promise(fn)；

   ②Promise.resolve(fn)；

 

⑸Promise特点：

  ①对象的状态不受外界影响；

  ②一旦状态改变，就不会再变，任何时候都可以得到这个结果；

 

⑹Promise方法：

​    ①Promise.all( [promise1，promise2，promise3] ).then( )；

作为参数的几个promise对象一旦有一个的状态为rejected，则all的返回值就是rejected。

当这几个作为参数的函数的返回状态为fulfilled时，至于输出的时间就要看谁跑的慢了。

var  p1 = Promise.resolve(1),

   p2 = Promise.reject(2),

   p3 = Promise.resolve(3);

Promise.all([p1, p2, p3]).then((res)=>{

  //then方法不会被执行

  console.log(results);

}).catch((err)=>{

  //catch方法将会被执行，输出结果为：2

  console.log(err);

});复制代码

​    ②promise.race( )：从字面意思上理解就是竞速，那么理解起来上就简单多了，也就是说在数组中的元素实例那个率先改变状态，就向下传递谁的状态和异步结果。但是，其余的还是会继续进行的。

let p1 = new Promise((resolve)=>{

setTimeout(()=>{

  console.log('1s') //1s后输出

resolve(1)

 },1000)

})

let p10 = new Promise((resolve)=>{

setTimeout(()=>{

  console.log('10s') //10s后输出

  resolve(10) //不传递

 },10000)

})

let p5 = new Promise((resolve)=>{

setTimeout(()=>{

  console.log('5s') //5s后输出

  resolve(5) //不传递

 },5000)

})

Promise.race([p1, p10, p5]).then((res)=>{

  console.log(res); // 最后输出

})

//结果：

1s

1

5s

10s

##### 7.var、let和const的区别

①变量提升：var存在变量提升，可以在声明之前使用，而let和const在声明之前使用会报错。

②重复声明：在相同作用域内，let和const不允许重复声明。

③暂时性死区：

var tmp = 123;if(true){   tmp = "abc";   let tmp;  //报错}复制代码

④初始值：const声明的是一个常量，不可以改变，一旦声明就必须给赋值。const所说的一旦声明值就不能改变，实际上指的是：变量指向的那个内存地址所保存的数据不得改动。

##### 8.async 和 await

async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await`就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。

优点 ： Async 函数的实现最简洁，最符合语义，几乎没有语义不相关的代码。它将 Generator 写法中的自动执行器，改在语言层面提供，不暴露给用户，因此代码量最少。如果使用 Generator 写法，自动执行器需要用户自己提供。

##### 9.GET 和 POST 请求的区别

GET 参数通过url传递，POST 放在 body 中。（http 协议规定，url在请求头中，所以大小限制很小）

GET 请求在url中传递的参数是有长度限制的，而 POST 没有。

GET 在浏览器回退时是无害的，而 POST 会再次提交请求

GET 请求会被浏览器主动 cache，而 POST 不会，除非手动设置

GET 比 POST 更不安全，因为参数直接暴露在url中，所以不能用来传递敏感信息

对参数的数据类型，GET 只接受 ASCII字符，而 POST 没有限制

GET 请求只能进行url(x-www-form-urlencoded)编码，而 POST 支持多种编码方式

***\*GET 产生一个 TCP 数据包；POST 产生两个 TCP 数据包\****。对于 GET 方式的请求，浏览器会把 http 的 header 和 data 一并发送出去，服务器响应200（返回数据）。而对于 POST，浏览器先发送 header，服务器响应100 continue，浏览器再发送 data，服务器响应200 ok（返回数据）

##### 10.什么是重绘？回流（重排）

\1. 当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流。每个页面至少需要一次回流，就是在页面第一次加载的时候。

\2. 当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘。

注：回流必将引起重绘，而重绘不一定会引起回流。

##### 11.nextTick 的理解

***\*使用nextTick的原因：\****Vue是异步修改DOM的，并且不鼓励开发者直接接触DOM，但是有时候需要必须对数据更改后的DOM元素做相应的处理，但是获取到的DOM数据并不是更改后的数据，这时候就需要this.$nextTick()；

***\*原理：\****Vue通过异步队列控制DOM更新和nextTick回调函数先后执行的方式。

##### 12.Vue的生命周期(11个钩子函数)

***\*⑴beforeCreate(创建前)：\****在此生命周期函数执行的时候，data和methods中的数据都还没有初始化。

***\*⑵created(创建后)：\****在此生命周期函数中，data和methods都已经被初始化好了，如果要调用 methods中的方法，或者操作data中的数据，最早只能在created中操作。

***\*⑶beforeMount(载入前)：\****在此生命周期函数执行的时候，模板已经在内存中编译好了，但是尚未挂载到页面中去，此时页面还是旧的。

***\*⑷mounted(载入后)：\****此时页面和内存中都是最新的数据，这个钩子函数是最早可以操作dom节点的方法。

***\*⑸beforeUpdate(更新前)：\****此时页面中显示的数据还是旧的，但是data中的数据是最新的，且页面并未和最新的数据同步。

***\*⑹Updated(更新后)：\****此时页面显示数据和最新的data数据同步。

***\*⑺beforeDestroy(销毁前)：\****当执行该生命周期函数的时候，实例身上所有的data，所有的methods以及过滤器......等都处于可用状态，并没有真正执行销毁。

***\*⑻destroyed(销毁后)：\****此时组件以及被完全销毁，实例中的所有的数据、方法、属性、过滤器......等都已经不可用了。

//下面两个钩子函数一般配合<keep-alive></keep-alive>使用

***\*⑼activated(组件激活时)：\****和上面的beforeDestroy和destroyed用法差不多，但是如果我们需要一个实例，在销毁后再次出现的话，用beforeDestroy和destroyed的话，就太浪费性能了。实例被激活时使用，用于重复激活一个实例的时候
***\*⑽deactivated(组件未激活时)：\****实例没有被激活时。
***\*⑾errorCaptured(错误调用)：\****当捕获一个来自后代组件的错误时被调用

##### 13.watch、computed和methods的区别

· methods即是方法，封装的功能代码块，调用后执行。在重新渲染的时候每次都会被重新的调用；

· computed 是自动监听依赖值的变化，从而动态返回内容，主要目的是简化模板内的复杂运算。所以区别来源于用法，只是需要动态值，那就用 computed ；需要知道值的改变后执行业务逻辑，才用 watch。

·  watch也可以影响数据的变化，当绑定的数据方法变化时触发响应的函数，需要在数据变化时执行异步或开销较大的操作时使用watch。

##### 14.Vuex的理解？Vuex的五大核心？

***\*定义：\****Vuex是一个专为Vue.js应用程序开发的状态管理模式。它采用集中式储存管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。

***\*使用场景：\****需要构建一个中大型单页应用，您很可能会考虑如何更好的在组件外部管理状态，Vuex将会成为自然而然的选择。

***\*优点：\****当你在state中定义了一个数据之后，可以在所在项目中的任何一个组件里进行获取、进行修改、并且你的修改可以得到全局的响应变更。

***\*①state：\****定义初始数据。
***\*②mutations：\****更改Vuex的store中的状态的唯一方法是提交mutation
***\*③getters：\****可以对 state 进行计算操作，它就是 store 的计算属性虽然在组件内也可以做计算属性，但是 getters 可以在多给件之间复用如果一个状态只在一个组件内使用，是可以不用 getters。
***\*④actions：\****异步操作初始数据，其实就是调用mutations里面的方法。
***\*⑤module：\****面对复杂的应用程序，当管理的状态比较多时；我们需要将vuex的store对象分割成模块(modules)。

##### 15.什么叫优雅降级和渐进增强

渐进增强 progressive enhancement：
针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。

优雅降级 graceful degradation：
一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。

区别：
	a. 优雅降级是从复杂的现状开始，并试图减少用户体验的供给
	b. 渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要
	c. 降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带

##### 16.对vue的理解（原理）

是一个MVVM模式的框架，解释一下MVVM
首先vue是一个由数据驱动，组件化两大核心组成的框架。它基于mvvm模式。
组件化就是实现了扩展 HTML 元素，封装可用的代码，提高代码的复用性。
Vue是一个提供了MVVM风格的双向数据绑定的 Javascript 库，专注于 View 层。它让开发者省去了操作 DOM 的过程，只需要改变数据即可。
特点:简洁、轻量、快速、数据驱动、组件化、模块友好。

##### 17.继承

js继承实现方式有很多，分为ES5和ES6

###### ES5：

ES5实现继承主要是基于prototype来实现

假设有俩个类A和B     B去继承A

1.原型链继承 B.prototype = new.A()

2.构造函数继承：分俩种call和apply方式

function  B（name,age){

A.call(this,name,age)

}

3.组合继承，也就是结合原型链继承和构造函数继承；

###### ES6：

ES6继承是目前比较新，并且主流的继承方式，用class定义类，用extends继承类，用super()表示父类



继承有：

1，原型链继承
2，借用构造函数继承
3，组合继承(原型+借用构造)
4，原型式继承
5，寄生式继承
6，寄生组合式继承

##### 18.js原生常用的dom操作方法：

js原生dom操作方法有？

​    查找：getElementByid,

​               getElementsByTagName,

​               querySelector,

​               querySelectorAll

​    插入：appendChild,insertBefore

​    删除：removeChild

​    克隆：cloneNode

​    设置和获取属性：setAttribute(“属性名”,”值”),getAttibute(“属性名”)

##### 19.js面向对象的理解：

JS面向对象主要基于function来实现的，通过function来模拟类，通过prototype来实现类方法的共享，跟其他语言有着本质的不同，自从有了ES6后，把面向对象类的实现更像后端语言的实现了，通过class来定义类，通过extends来继承父类，其实ES6类的实现本质上是一个语法糖，不过对于开发简单了好多。

##### 20.js数组内置遍历方法有那些和区别：

***\*forEach:\****这个方法是为了取代for循环遍历数组的，返回值为undefined

***\*filter:\****是一个过滤遍历的方法，如果返回条件为true，则返回满足条件为true的新数组

***\*map:\****这个map方法主要对数组的复杂逻辑处理时用的多，特别是react中遍历数据，也经常用到，写法和forEach类似

***\*some:\****这个some方法用于只要数组中至少存在一个满足条件的结果，返回值就为true,否则返回fasel, 写法和forEach类似

***\*every:\****这个every方法用于数组中每一项都得满足条件时，才返回true，否则返回false, 写法和forEach类似

##### 21.call,apply,bind区别：

call,apply,bind主要作用都是改变this指向的， call和apply的主要区别是在传递参数上不同，call后面传递的参数是以逗号的形式分开的，apply传递的参数是数组形式  [Apply是以A开头的,所以应该是跟Array(数组)形式的参数]

 bind返回的是一个函数形式，如果要执行，则后面要再加一个小括号 例如：bind(obj,参数1,参数2,)(),bind只能以逗号分隔形式，不能是数组形式

22.Vue最大特点：

组件化和数据驱动

组件化就是可以将页面和页面中可复用的元素都看做成组件，写页面的过程，就是写组件，然后页面是由这些组件“拼接“起来的组件树

  数据驱动就是让我们只关注数据层，只要数据变化，页面（即视图层）会自动更新，至于如何操作dom，完全交由vue去完成，咱们只关注数据，数据变了，页面自动同步变化了，很方便

##### 23.单向数据流和双向数据流：

###### 单向数据流

所有状态的改变可记录、可跟踪，源头易追溯；所有数据只有一份，组件数据只有唯一的入口和出口，使得程序更直观更容易理解，有利于应用的可维护性；一旦数据变化，就去更新页面；如果用户在页面上做了变动，那么就手动收集起来(双向是自动)，合并到原有的数据中。

###### 双向数据绑定

无论数据改变，或是用户操作，都能带来互相的变动，自动更新。

最后举个例子，vue中父传子的props就是单向数据流，而v-modal就是双向数据流

##### 24.webpack的理解：

webpack是一个前端模块化打包构建工具，vue脚手架本身就用的webpack来构建的，webpack本身需要的入口文件通过entry来指定，出口通过output来指定，默认只支持js文件，其他文件类型需要通过对应的loader来转换，例如：less需要less,less-loader,sass需要sass-loader,css需要style-loader,css-loader来实现。当然本身还有一些内置的插件来对文件进行压缩合并等操作

##### 25.vuex的理解

vuex是一个状态管理工具，主要解决大中型复杂项目的数据共享问题，主要包括state,actions,mutations,getters和modules 5个要素，主要流程：组件通过dispatch到 actions，actions是异步操作，再actions中通过commit到mutations，mutations再通过逻辑操作改变state，从而同步到组件，更新其数据状态,而getters相当于组件的计算属性对,组件中获取到的数据做提前处理的.再说到辅助函数的作用.

##### 26.computed 和 watch 的区别和运用场景：

***\*computed：\**** 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；

***\*watch：\**** 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；

##### 27.vue-router路由模式有几种：

vue-router 有 3 种路由模式：hash、history、abstract。

其中，3 种路由模式的说明如下：

· hash: 使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器；

· history : 依赖 HTML5 History API 和服务器配置。具体可以查看 HTML5 History 模式；

· abstract : 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式.

***\*hash 模式的实现原理\****

早期的前端路由的实现就是基于 location.hash 来实现的。其实现原理很简单，location.hash 的值就是 URL 中 # 后面的内容。

***\*history 模式的实现原理\****

HTML5 提供了 History API 来实现 URL 的变化。其中做最主要的 API 有以下两个：history.pushState() 和 history.repalceState()。这两个 API 可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录。

##### 28.你有对Vue项目进行哪些优化

如果没有对 Vue 项目没有进行过优化总结的同学，可以参考另一篇文章[《 Vue 项目性能优化 — 实践指南 》](https://juejin.im/post/5d548b83f265da03ab42471d)，文章主要介绍从 3 个大方面，22 个小方面详细讲解如何进行 Vue 项目的优化。

***\*（1）代码层面的优化\****

· v-if 和 v-show 区分使用场景

· computed 和 watch 区分使用场景

· v-for 遍历必须为 item 添加 key，且避免同时使用 v-if

· 长列表性能优化

· 事件的销毁

· 图片资源懒加载

· 路由懒加载

· 第三方插件的按需引入

· 优化无限列表性能

· 服务端渲染 SSR or 预渲染

***\*（2）Webpack 层面的优化\****

· Webpack 对图片进行压缩sg 

· 减少 ES6 转为 ES5 的冗余代码

· 提取公共代码

· 模板预编译

· 提取组件的 CSS

· 优化 SourceMap

· 构建结果输出分析

· Vue 项目的编译优化

***\*（3）基础的 Web 技术的优化\****

· 开启 gzip 压缩

· 浏览器缓存

· CDN 的使用

· 使用 Chrome Performance 查找性能瓶颈

##### 29.ES6新增特性：

答：ES6新增特性常用的主要有：let/const,箭头函数，模板字符串，解构赋值，模块的导入(import)和导出(export default/export),Promise,还有一些数组字符串的新方法,其实有很多，我平时常用的就这些

##### 30.vue怎么实现动态路由：

第一种方式：

1、在需要传参的vue文件的router-link标签上的to属性后面写上需要传递的参数。
2、在router目录下的index.js文件中，对应path属性加上/：id。
3、在需要使用参数的vue文件使用router对象的params.id接收传递过来的参数。



第二种方式：

1、使用this.$router.push('路径/'+ 参数)
2、在router目录下的index.js文件中，对应path属性加上/：id。
3、在需要使用参数的vue文件使用router对象的params.id接收传递过来的参数。

##### 31.xml和json的区别：

(1).数据体积方面。
	JSON相对于XML来讲，数据的体积小，传递的速度更快些。
(2).数据交互方面。
	JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。
(3).数据描述方面。
	JSON对数据的描述性比XML较差。
(4).传输速度方面。
	JSON的速度要远远快于XML。

##### 32.优雅降级和渐进增强：

渐进增强 progressive enhancement：
针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。

优雅降级 graceful degradation：
一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。

区别：
	a. 优雅降级是从复杂的现状开始，并试图减少用户体验的供给
	b. 渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要
	c. 降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带

##### 33.什么是前后端分离以及优点：

前后端之间使用 JSON 来交流，两个开发团队之间使用 API 作为契约进行交互

提高工作效率，分工更加明确，局部性能提升，降低维护成本。前端只关注前端的事，后台只关心后台的活，两者开发可以同时进行，在后台还没有时间提供接口的时候，前端可以先将数据写死或者调用本地的JSON文件即可

##### 34.**通信原因**：

AJAX

Ajax通信实质上是js创建了一个XMLHttpRequest对象，这个对象有个open（）方法，其参数包含url，methods，callback等，通过这个方法设置其属性，而后通过send()方法向后台发送请求。

axios

通过XMLHttpRequest和process来判断是浏览器还是node环境，从而在不同的环境提供不同的http请求模块，实现客户端和服务端程序的兼容。

##### 35.vue中v-if和v-show的区别：

 v-if 是真正的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和⼦组件适当地被销毁和重建；也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第⼀次变为真时，才会开始渲染条件块。

v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 “display” 属性进⾏切换

v-if 适⽤于条件很少改变时使用，

v-show则适⽤于条件频繁切换时使用。

##### 36.把token值放到哪里，token值有过期时间吗？

通常情况下我们会将token值存放到本地存储中

有过期时间

##### 37.vue3的双向数据绑定Proxy

Vue3.0摒弃了Object.defineProperty，改为基于Proxy的观察者机制探索。

首先说一下***\*Object.defineProperty的缺点\****：

· ①Object.defineProperty无法监控到数组下标的变化，导致直接通过数组的下标给数组设置值，不能实施响应。

· ②Object.defineProperty只能劫持对象的属性，因此我们需要对每个对象的每个属性进行遍历。Vue2.X里，是通过递归 + 遍历data对象来实现对数据的监控的，如果属性值也是对象那么需要深度遍历，显然如果能劫持一个完整的对象才是更好的选择。

***\*而要取代它的Proxy有以下两个优点：\****

· 可以劫持整个对象，并返回一个新对象。

· 有多种劫持操作(13种)

***\*补充：\****

· Proxy是ES6新增的一个属性，翻译过来的意思就是代理，用在这里表示由它来“代理”某些操作。Proxy让我们能够以简洁易懂的方式控制外部对象的访问，其功能非常类似于设计模式中的代理模式。

· Proxy可以理解为，在目标对象之前设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。

· 使用Proxy的核心优点是可以交由它来处理一些非核心逻辑(如：读取或设置对象的某些属性前记录日志；设置对象的某些属性值前，需要验证；某些属性的访问控制等)。从而可以让对象只需要关注核心逻辑，达到关注点分离，降低对象复杂度等目的。

##### 38.vue.js的特点:

· 简洁：页面由HTML模板+Json数据+Vue实例组成

· 数据驱动：自动计算属性和追踪依赖的模板表达式

· 组件化：用可复用、解耦的组件来构造页面

· 轻量：代码量小，不依赖其他库

· 快速：精确有效批量DOM更新

· 模板友好：可通过npm，bower等多种方式安装，很容易融入

##### 39.vuex的运行机制：

Vuex提供数据（state）来驱动视图（vue components），通过dispath派发actions，在其中可以做一些异步的操作，然后通过commit来提交mutations，最后mutations来更改state。

##### 40.vue的响应式原理：

当一个Vue实例创建时，vue会遍历data选项的属性，用 Object.defineProperty 将它们转为 getter/setter并且在内部追踪相关依赖，在属性被访问和修改时通知变化。 每个组件实例都有相应的 watcher 程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新。

##### 41.vue-router有哪几种导航钩子

① 全局导航钩子：一般用来判断权限，以及页面丢失时需要执行的操作；

   beforeEach（）每次路由进入之前执行的函数。

   afterEach（）每次路由进入之后执行的函数。

   beforeResolve（）2.5新增

② 单个路由（实例钩子）：某个指定路由跳转时需要执行的逻辑。

   beforeEnter（）

   beforeLeave（）

③ 组件路由钩子：

  beforeRouteEnter（）

  beforeRouteLeave（）

  beforeRouteUpdate（）

##### 42.vue组件中data为什么是一个函数：

如果data是一个函数的话，这样每复用一次组件，就会返回一份新的data，类似于给每个组件实例创建一个私有的数据空间，让各个组件实例维护各自的数据。Object是引用数据类型，里面保存的是内存地址，单纯的写成对象形式，就使得所有组件实例共用了一份data，就会造成一个变了全都会变的结果。

所以说vue组件的data必须是函数。

##### 43.请说出vue-cli项目中src目录每个文件夹和文件的用法：

assets文件夹是放静态资源；
components是放组件；
router是定义路由相关的配置;
view视图；
app.vue是一个应用主组件；
main.js是入口文件

##### 44.route和router的区别：

route是“路由信息对象”，包括path,params,hash,query,fullPath,matched,name等路由信息参数。

router是“路由实例对象”，包括了路由的跳转方法(push、go)，钩子函数等。

##### 45.vue和react的区别：

·***\*监听数据变化的实现原理不同：\****Vue 通过 getter/setter 以及一些函数的劫持，能精确快速的计算出 vdom 的差异。这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。React 默认是通过比较引用的方式进行的，如果不优化，每当应用的状态被改变时，全部子组件都会重新渲染，可能导致大量不必要的 VDOM 的重新渲染。

·***\*数据流的不同：\****Vue 中默认支持双向绑定，组件与 DOM 之间可以通过 v-model 双向绑定。但是，父子组件之间，props 在 2.x 版本是单向数据流。React 一直提倡的是单向数据流。

·***\*模板渲染方式的不同：\****React 是通过 JSX 渲染模板，而 Vue 是通过一种拓展的 HTML 语法进行渲染

##### 46.axios拦截器：

要想统一处理所有http请求和响应，就得用上 axios 的拦截器

//响应拦截

axios.interceptors.response.use(function(response){

  //对响应数据做点什么

  return response.data

},function(error){

  //对错误响应做点什么

  return Promise.reject(error)

})

//请求拦截

axios.interceptors.request.use(function(config){

  //在发送请求之前做些什么

  return config

},function(error){

  //对请求错误做些什么

  return Promise.reject(error)

})

##### 47.px和em和rem的区别

1、px实际上就是像素，与物理像素有一定的区别，用px设置字体大小，比较精确，但是有缺点，当浏览器页面缩放时，px并不能跟随变大。当前网页的布局就会被打破。

2、em是根据基准来缩放字体的大小。em是相对单位，一般都是以<body>的字体大小作基准的。em是相对于父元素的属性来计算的，这样就会存在一个问题，就是每一层父元素都必须有它的数值。

3、而rem不同，rem是相对于根元素html,而此时我们只需要以rem为基准就可以了

##### 48.请描述一下cookies，sessionStorage和localStorage的区别？

***\*sessionStorage\****用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。

***\*localStorage\****用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。

 

***\*webStorage和cookie的区别\****

 

WebStorage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。

除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie。但是Cookie也是不可以或缺的：Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生。

##### 49.响应式布局的方法（5个）：

1.百分比布局：利用对属性设置百分比来适配不同屏幕

2.使用媒体查询（css3@media查询）：利用媒体查询设置不同分辨率下的css 样式，来适配不同屏幕

3.rem响应式布局：当前页面中元素的rem 单位的样式值都是针对于html 元素的font-size 的值进行动态计算的；

4.vw响应式布局：

根据 PSD 文件宽度或高度作为标准，元素单位 px 转换为 vw 或 vh

5.flex弹性盒子布局：利用 flex 属性来适配不同屏幕

##### 50.js判断数据类型的方法：

1.typeof：基本数据类型没有问题，引用数据类型有问题。

当变量是：number, string, boolean, function, undefined, object类型时，可以使用typeof进行判断。

当变量是arr, json, null, date, reg, error 类型时全部被错误的检测为object类型。

2.instanceof：基本数据类型会有问题，而引用数据类型没有问题。

3.constructor：除了undefined和null，其它变量都能使用constructor判断类型

4. Object.prototype.toString.call
5. ⑤ jquery中的$.type（）

##### 51.argument的解释：

arguments是一个类似于数组的对象，对应于传递给函数的参数，他有length属性，可以arguments[ i ]来访问对象中的元素，但是它不能用数组的一些方法。例如push、pop、slice等。arguments虽然不是一个数组，但是它可以转成一个真正的数组。

##### 52.Ajax原生写法：

var xhr;   //创建ajax对象

if(window.XMLHttpRequest){  //兼容IE

  xhr = new XMLHttpRequest();

}else{

  xhr = new ActiveXObject("Microsoft.XMLHTTP");

}

xhr.open("get",url,true);  //建立连接

xhr.send();  //发送

xhr.onreadystatechange = function(){  //获取数据

  if(xhr.readyState == 4 && xhr.status == 200){

​    var data = JSON.parse(xhr.responseText);

  }

}

##### 53.对象和面向对象：

对象：

属性和方法的集合叫做对象（万物皆对象）。

面向对象：

首先就是找对象，如果该对象不具备所需要的方法或属性，那就给它添加。面向对象是一种编程思维的改变。通过原型的方式来实现面向对象编程。

创建对象的方式(4种)：

new Object、字面量、构造函数、原型。

##### 54.函数柯里化：

概念：

把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数而且返回结果的新函数的技术。

 

容易理解的概念：

Currying概念其实很简单，只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数（主要是利用闭包实现的）。

 

特点： 

①接收单一参数，将更多的参数通过回调函数来搞定；

②返回一个新函数，用于处理所有的想要传入的参数；

③需要利用call/apply与arguments对象收集参数；

④返回的这个函数正是用来处理收集起来的参数。

 

作用：

能进行部分传值，而传统函数调用则需要预先确定所有实参。如果你在代码某一处只获取了部分实参，然后在另一处确定另一部分实参，这个时候柯里化和偏应用就能派上用场。

##### 55.iframe的优缺点有那些：

优点：

①iframe能够原封不动的把嵌入的网页展现出来；

②如果有多个网页引用iframe，那么你只需要修改iframe的内容，就可以实现调用的每一个页面内容的更改，方便快捷。

③网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用iframe来嵌套，可以增加代码的可重用。

④如果遇到加载缓慢的第三方内容如图标和广告，这些问题可以由iframe来解决。

 

缺点：

①会产生很多页面不易管理；

②iframe框架结构有时会让人感到迷惑，如果框架个数多的话，可能会出现上下、左右滚动条，会分散访问者的注意力，用户体验度差。

③代码复杂，无法被一些搜索引擎索引到，这一点很关键，现在的搜索引擎爬虫还不能很好的处理iframe中的内容，所以使用iframe会不利于搜索引擎优化。

④很多的移动设备（PDA 手机）无法完全显示框架，设备兼容性差。

⑤iframe框架页面会增加服务器的http请求，对于大型网站是不可取的。

56.宏任务   微任务：

宏：

MacTasks。

setTimeout、setInterval 、setImmediate 、requestAnimationFrame 。

微：

process.nextTick、MutationObserver 、Promise。

##### 56.什么是重绘什么是回流：

\1. 当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流。每个页面至少需要一次回流，就是在页面第一次加载的时候。

\2. 当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘。

注：回流必将引起重绘，而重绘不一定会引起回流。

##### 平时怎么学习新技术的？

答：上官网看文档，上github上找相关开源项目练手，上技术社区博客园，csdn,51cto,掘金，简书参加技术问题讨论，上知乎，通过专业书籍（例如：高程三，javascript权威指南即犀牛书）系统学习，加入相关技术群参考讨论，

##### 未来的职业规划是什么？

答：2年内先做好技术，小有所成后，其他机会也就慢慢来了

 

##### Websocket知识点:

它是一种做及时性聊天的技术,在用的过程中,首先初始化一个websocket实例,当我要发送数据的时候触发onopen方法里面的send方法,携带发送的内容,接收服务器的数据是onmessage方法,关闭本次长链接用onclose方法

这个东西其实和ajax比较像,有具体固定的格式步骤.只不是这种是长链接,ajax技术是短连接,局部刷新

